This problem follows the classic prefix sum + modulo frequency pattern, where we are asked to count subarrays whose sum is divisible by n. The key idea is that if two prefix sums leave the same remainder when divided by n, then the subarray between them has a sum divisible by n. Therefore, instead of focusing on the actual prefix sum values, we must track how many times each remainder (prefix sum modulo n) appears and use those frequencies to count valid subarrays efficiently.

In my solution, I made three important mistakes. First, I incorrectly assumed that if the prefix sum was smaller than n, it could not contribute to a valid subarray, which is wrong because divisibility depends only on the remainder, not on the magnitude of the sum. Second, I stored the full prefix sum in the map instead of storing its remainder modulo n, which broke the core logic of the pattern since only remainders matter for detecting divisible subarrays. Third, I did not handle negative modulo properly, which is critical because the array elements can be negative and C++ can produce negative remainders; failing to normalize the remainder can lead to incorrect counting. The correct approach is to consistently work with normalized prefix sum remainders and maintain their frequencies throughout the iteration.
